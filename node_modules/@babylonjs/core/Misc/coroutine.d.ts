/**
 * A Coroutine<T> is the intersection of:
 * 1. An Iterator that yields void, returns a T, and is not passed values with calls to next.
 * 2. An IterableIterator of void (since it only yields void).
 */
declare type CoroutineBase<TStep, TReturn> = Iterator<TStep, TReturn, void> & IterableIterator<TStep>;
/** @hidden */
export declare type Coroutine<T> = CoroutineBase<void, T>;
/** @hidden */
export declare type AsyncCoroutine<T> = CoroutineBase<void | Promise<void>, T>;
/** @hidden */
export declare type CoroutineStep<T> = IteratorResult<void, T>;
/** @hidden */
export declare type CoroutineScheduler<T> = (coroutine: AsyncCoroutine<T>, onSuccess: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => void;
/** @hidden */
export declare function inlineScheduler<T>(coroutine: AsyncCoroutine<T>, onSuccess: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void): void;
/** @hidden */
export declare function createYieldingScheduler<T>(yieldAfterMS?: number): (coroutine: AsyncCoroutine<T>, onSuccess: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => void;
/** @hidden */
export declare function runCoroutine<T>(coroutine: AsyncCoroutine<T>, scheduler: CoroutineScheduler<T>, onSuccess: (result: T) => void, onError: (error: any) => void, abortSignal?: AbortSignal): void;
/** @hidden */
export declare function runCoroutineSync<T>(coroutine: Coroutine<T>, abortSignal?: AbortSignal): T;
/** @hidden */
export declare function runCoroutineAsync<T>(coroutine: AsyncCoroutine<T>, scheduler: CoroutineScheduler<T>, abortSignal?: AbortSignal): Promise<T>;
/** @hidden */
declare type ExtractCoroutineReturnType<T> = T extends Coroutine<infer TReturn> ? TReturn : never;
/** @hidden */
declare type ExtractAsyncCoroutineReturnType<T> = T extends Coroutine<infer TReturn> ? Promise<TReturn> : T extends AsyncCoroutine<infer TReturn> ? Promise<TReturn> : never;
/**
 * Given a function that returns a Coroutine<T>, produce a function with the same parameters that returns a T.
 * The returned function runs the coroutine synchronously.
 * @param coroutineFactory A function that returns a Coroutine<T>.
 * @returns A function that runs the coroutine synchronously.
 * @hidden
 */
export declare function makeSyncFunction<TCoroutineFactory extends (...params: any[]) => Coroutine<unknown>, TReturn extends ExtractCoroutineReturnType<ReturnType<TCoroutineFactory>>>(coroutineFactory: TCoroutineFactory, abortSignal?: AbortSignal): (...params: Parameters<TCoroutineFactory>) => TReturn;
/**
 * Given a function that returns a Coroutine<T>, product a function with the same parameters that returns a Promise<T>.
 * The returned function runs the coroutine asynchronously, yield control of the execution context occasionally to enable a more responsive experience.
 * @param coroutineFactory A function that returns a Coroutine<T>.
 * @returns A function that runs the coroutine asynchronously.
 * @hidden
 */
export declare function makeAsyncFunction<TCoroutineFactory extends (...params: any[]) => AsyncCoroutine<unknown>, TReturn extends ExtractAsyncCoroutineReturnType<ReturnType<TCoroutineFactory>>>(coroutineFactory: TCoroutineFactory, scheduler: CoroutineScheduler<unknown>, abortSignal?: AbortSignal): (...params: Parameters<TCoroutineFactory>) => TReturn;
export {};
