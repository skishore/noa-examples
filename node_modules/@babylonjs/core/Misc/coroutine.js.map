{"version":3,"file":"coroutine.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/coroutine.ts"],"names":[],"mappings":"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","sourcesContent":["// \"Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed.\"\n// https://en.wikipedia.org/wiki/Coroutine\n\n// In this implementation, coroutines are typically created via generator functions (function* with yield statements).\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n\n// In this implementation, the generator function (possibly parameterized) is referred to as a coroutine factory, and the returned iterator is referred to as the coroutine.\n// Technically yielding generator functions are not required - anything that implements the contract of Coroutine<T> can be run as a coroutine.\n\n// The coroutine is started with the first call to next on the iterator, it is suspended with yield statements, and it is resumed with additional calls to next on the iterator.\n// To create an object satisfying the Coroutine<T> contract with a generator function, it must not yield values, but rather only void via a plain \"yield;\" statement.\n// Coroutines can call other coroutines via:\n// 1. yield* someOtherCoroutine(); // If the called coroutine does not return a value\n// 2. const result = yield* someOtherCoroutine(); // If the called coroutine returns a value\n\n// Coroutines are run with the runCoroutine function, which takes a Coroutine<T>, a CoroutineScheduler<T>, and a success and error callback.\n// A scheduler is responsible for scheduling the next step of a coroutine, either synchronously or asynchronously.\n\n/**\n * A Coroutine<T> is the intersection of:\n * 1. An Iterator that yields void, returns a T, and is not passed values with calls to next.\n * 2. An IterableIterator of void (since it only yields void).\n */\ntype CoroutineBase<TStep, TReturn> = Iterator<TStep, TReturn, void> & IterableIterator<TStep>;\n/** @hidden */\nexport type Coroutine<T> = CoroutineBase<void, T>;\n/** @hidden */\nexport type AsyncCoroutine<T> = CoroutineBase<void | Promise<void>, T>;\n\n// A CoroutineStep<T> represents a single step of a coroutine, and is an IteratorResult as returned from Coroutine<T>.next().\n/** @hidden */\nexport type CoroutineStep<T> = IteratorResult<void, T>;\n\n// A CoroutineScheduler<T> is responsible for scheduling the call to Coroutine<T>.next and invokes the success or error callback after next is called.\n/** @hidden */\nexport type CoroutineScheduler<T> = (coroutine: AsyncCoroutine<T>, onSuccess: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => void;\n\n// The inline scheduler simply steps the coroutine synchronously. This is useful for running a coroutine synchronously, and also as a helper function for other schedulers.\n/** @hidden */\nexport function inlineScheduler<T>(coroutine: AsyncCoroutine<T>, onSuccess: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) {\n    try {\n        const step = coroutine.next();\n\n        if (step.done) {\n            onSuccess(step);\n        } else if (!step.value) {\n            // NOTE: The properties of step have been narrowed, but the type of step itself is not narrowed, so the cast below is the most type safe way to deal with this without instantiating a new object to hold the values.\n            onSuccess(step as {done: typeof step.done, value: typeof step.value});\n        } else {\n            step.value.then(\n                () => {\n                    step.value = undefined;\n                    onSuccess(step as {done: typeof step.done, value: typeof step.value});\n                },\n                (error) => onError(error),\n            );\n        }\n    } catch (error) {\n        onError(error);\n    }\n}\n\n// The yielding scheduler steps the coroutine synchronously until the specified time interval has elapsed, then yields control so other operations can be performed.\n// A single instance of a yielding scheduler could be shared across multiple coroutines to yield when their collective work exceeds the threshold.\n/** @hidden */\nexport function createYieldingScheduler<T>(yieldAfterMS = 25) {\n    let startTime: number | undefined;\n    return (coroutine: AsyncCoroutine<T>, onSuccess: (stepResult: CoroutineStep<T>) => void, onError: (stepError: any) => void) => {\n        const currentTime = performance.now();\n\n        if (startTime === undefined || currentTime - startTime > yieldAfterMS) {\n            // If this is the first coroutine step, or if the time interval has elapsed, record a new start time, and schedule the coroutine step to happen later, effectively yielding control of the execution context.\n            startTime = currentTime;\n            setTimeout(() => {\n                inlineScheduler(coroutine, onSuccess, onError);\n            }, 0);\n        } else {\n            // Otherwise it is not time to yield yet, so step the coroutine synchronously.\n            inlineScheduler(coroutine, onSuccess, onError);\n        }\n    };\n}\n\n// Runs the specified coroutine with the specified scheduler. The success or error callback will be invoked when the coroutine finishes.\n/** @hidden */\nexport function runCoroutine<T>(coroutine: AsyncCoroutine<T>, scheduler: CoroutineScheduler<T>, onSuccess: (result: T) => void, onError: (error: any) => void, abortSignal?: AbortSignal) {\n    function resume() {\n        if (!abortSignal || !abortSignal.aborted) {\n            scheduler(coroutine,\n                (stepResult: CoroutineStep<T>) => {\n                    if (stepResult.done) {\n                        // If the coroutine is done, report success.\n                        onSuccess(stepResult.value);\n                    } else {\n                        // If the coroutine is not done, resume the coroutine (via the scheduler).\n                        resume();\n                    }\n                },\n                (error: any) => {\n                    // If the coroutine threw an error, report the error.\n                    onError(error);\n                });\n        } else {\n            onError(\"Aborted\");\n        }\n    }\n\n    resume();\n}\n\n// Runs the specified coroutine synchronously.\n/** @hidden */\nexport function runCoroutineSync<T>(coroutine: Coroutine<T>, abortSignal?: AbortSignal): T {\n    // Run the coroutine with the inline scheduler, storing the returned value, or re-throwing the error (since the error callback will be called synchronously by the inline scheduler).\n    let result: T | undefined;\n    runCoroutine(coroutine, inlineScheduler, (r: T) => result = r, (e: any) => { throw e; }, abortSignal);\n\n    // Synchronously return the result of the coroutine.\n    return result!;\n}\n\n// Runs the specified coroutine asynchronously with the specified scheduler.\n/** @hidden */\nexport function runCoroutineAsync<T>(coroutine: AsyncCoroutine<T>, scheduler: CoroutineScheduler<T>, abortSignal?: AbortSignal): Promise<T> {\n    // Run the coroutine with a yielding scheduler, resolving or rejecting the result promise when the coroutine finishes.\n    return new Promise((resolve, reject) => {\n        runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);\n    });\n}\n\n// This is a helper type to extract the return type of a Coroutine<T>. It is conceptually very similar to the Awaited<T> utility type.\n/** @hidden */\ntype ExtractCoroutineReturnType<T> =\n    T extends Coroutine<infer TReturn> ? TReturn :\n    never;\n\n// This is a helper type to extract the return type of an AsyncCoroutine<T>.\n/** @hidden */\ntype ExtractAsyncCoroutineReturnType<T> =\n    T extends Coroutine<infer TReturn> ? Promise<TReturn> :\n    T extends AsyncCoroutine<infer TReturn> ? Promise<TReturn> :\n    never;\n\n/**\n * Given a function that returns a Coroutine<T>, produce a function with the same parameters that returns a T.\n * The returned function runs the coroutine synchronously.\n * @param coroutineFactory A function that returns a Coroutine<T>.\n * @returns A function that runs the coroutine synchronously.\n * @hidden\n */\nexport function makeSyncFunction<TCoroutineFactory extends (...params: any[]) => Coroutine<unknown>, TReturn extends ExtractCoroutineReturnType<ReturnType<TCoroutineFactory>>>(coroutineFactory: TCoroutineFactory, abortSignal?: AbortSignal): (...params: Parameters<TCoroutineFactory>) => TReturn {\n    return (...params: Parameters<TCoroutineFactory>): TReturn => {\n        // Run the coroutine synchronously.\n        return runCoroutineSync(coroutineFactory(...params), abortSignal) as TReturn;\n    };\n}\n\n/**\n * Given a function that returns a Coroutine<T>, product a function with the same parameters that returns a Promise<T>.\n * The returned function runs the coroutine asynchronously, yield control of the execution context occasionally to enable a more responsive experience.\n * @param coroutineFactory A function that returns a Coroutine<T>.\n * @returns A function that runs the coroutine asynchronously.\n * @hidden\n */\nexport function makeAsyncFunction<TCoroutineFactory extends (...params: any[]) => AsyncCoroutine<unknown>, TReturn extends ExtractAsyncCoroutineReturnType<ReturnType<TCoroutineFactory>>>(coroutineFactory: TCoroutineFactory, scheduler: CoroutineScheduler<unknown>, abortSignal?: AbortSignal): (...params: Parameters<TCoroutineFactory>) => TReturn {\n    return (...params: Parameters<TCoroutineFactory>): TReturn => {\n        // Run the coroutine asynchronously.\n        return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal) as TReturn;\n    };\n}\n"]}