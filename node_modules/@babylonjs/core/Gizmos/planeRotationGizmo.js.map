{"version":3,"file":"planeRotationGizmo.js","sourceRoot":"","sources":["../../../sourceES6/core/Gizmos/planeRotationGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../Misc/observable\";\nimport { Nullable } from \"../types\";\nimport { PointerInfo } from \"../Events/pointerEvents\";\nimport { Quaternion, Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Color3 } from '../Maths/math.color';\nimport \"../Meshes/Builders/linesBuilder\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { Node } from \"../node\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { Gizmo, GizmoAxisCache } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { RotationGizmo } from \"./rotationGizmo\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\nimport { Effect } from \"../Materials/effect\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\nimport { CreateTorus } from \"../Meshes/Builders/torusBuilder\";\n\n/**\n * Single plane rotation gizmo\n */\nexport class PlaneRotationGizmo extends Gizmo {\n    /**\n     * Drag behavior responsible for the gizmos dragging interactions\n     */\n    public dragBehavior: PointerDragBehavior;\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\n\n    /**\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\n     */\n    public snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the the change in distance\n     */\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\n\n    /**\n     * The maximum angle between the camera and the rotation allowed for interaction\n     * If a rotation plane appears 'flat', a lower value allows interaction.\n     */\n    public static MaxDragAngle: number = Math.PI * 9 / 20;\n\n    /**\n     * Acumulated relative angle value for rotation on the axis. Reset to 0 when a dragStart occurs\n     */\n    public angle: number = 0;\n\n    private _isEnabled: boolean = true;\n    private _parent: Nullable<RotationGizmo> = null;\n    private _coloredMaterial: StandardMaterial;\n    private _hoverMaterial: StandardMaterial;\n    private _disableMaterial: StandardMaterial;\n    private _gizmoMesh: Mesh;\n    private _rotationDisplayPlane: Mesh;\n    private _dragging: boolean = false;\n    private _angles = new Vector3();\n\n    private static _rotationGizmoVertexShader = `\n        precision highp float;\n        attribute vec3 position;\n        attribute vec2 uv;\n        uniform mat4 worldViewProjection;\n        varying vec3 vPosition;\n        varying vec2 vUV;\n        void main(void) {\n            gl_Position = worldViewProjection * vec4(position, 1.0);\n            vUV = uv;\n        }`;\n\n    private static _rotationGizmoFragmentShader = `\n        precision highp float;\n        varying vec2 vUV;\n        varying vec3 vPosition;\n        uniform vec3 angles;\n        #define twopi 6.283185307\n        void main(void) {\n            vec2 uv = vUV - vec2(0.5);\n            float angle = atan(uv.y, uv.x) + 3.141592;\n            float delta = gl_FrontFacing ? angles.y : -angles.y;\n            float begin = angles.x - delta * angles.z;\n            float start = (begin < (begin + delta)) ? begin : (begin + delta);\n            float end = (begin > (begin + delta)) ? begin : (begin + delta);\n            float len = sqrt(dot(uv,uv));\n            float opacity = 1. - step(0.5, len);\n\n            float base = abs(floor(start / twopi)) * twopi;\n            start += base;\n            end += base;\n\n            float intensity = 0.;\n            for (int i = 0; i < 5; i++)\n            {\n                intensity += max(step(start, angle) - step(end, angle), 0.);\n                angle += twopi;\n            }\n            gl_FragColor = vec4(1.,1.,0., min(intensity * 0.25, 0.8)) * opacity;\n        }`;\n\n    private _rotationShaderMaterial: ShaderMaterial;\n\n    /**\n     * Creates a PlaneRotationGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\n     * @param color The color of the gizmo\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\n     * @param thickness display gizmo axis thickness\n     */\n    constructor(planeNormal: Vector3, color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, parent: Nullable<RotationGizmo> = null, useEulerRotation = false, thickness: number = 1) {\n        super(gizmoLayer);\n        this._parent = parent;\n        // Create Material\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._coloredMaterial.diffuseColor = color;\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\n\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._disableMaterial.diffuseColor = Color3.Gray();\n        this._disableMaterial.alpha = 0.4;\n\n        // Build mesh on root node\n        this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n        const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);\n\n        // Setup Rotation Circle\n        this._rotationDisplayPlane = CreatePlane(\"rotationDisplay\", { size: 0.6, updatable: false }, this.gizmoLayer.utilityLayerScene);\n        this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;\n        this._rotationDisplayPlane.parent = this._gizmoMesh;\n        this._rotationDisplayPlane.setEnabled(false);\n\n        Effect.ShadersStore[\"rotationGizmoVertexShader\"] = PlaneRotationGizmo._rotationGizmoVertexShader;\n        Effect.ShadersStore[\"rotationGizmoFragmentShader\"] = PlaneRotationGizmo._rotationGizmoFragmentShader;\n        this._rotationShaderMaterial = new ShaderMaterial(\"shader\", this.gizmoLayer.utilityLayerScene, {\n            vertex: \"rotationGizmo\",\n            fragment: \"rotationGizmo\",\n        },\n            {\n                attributes: [\"position\", \"uv\"],\n                uniforms: [\"worldViewProjection\", \"angles\"]\n            });\n        this._rotationShaderMaterial.backFaceCulling = false;\n\n        this._rotationDisplayPlane.material = this._rotationShaderMaterial;\n        this._rotationDisplayPlane.visibility = 0.999;\n\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));\n        this._rootMesh.addChild(this._gizmoMesh);\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n        // Add drag behavior to handle events when the gizmo is dragged\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });\n        this.dragBehavior.moveAttached = false;\n        this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\n        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n        this._rootMesh.addBehavior(this.dragBehavior);\n\n        // Closures for drag logic\n        const lastDragPosition = new Vector3();\n\n        const rotationMatrix = new Matrix();\n        const planeNormalTowardsCamera = new Vector3();\n        let localPlaneNormalTowardsCamera = new Vector3();\n\n        this.dragBehavior.onDragStartObservable.add((e) => {\n            if (this.attachedNode) {\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n                this._rotationDisplayPlane.setEnabled(true);\n\n                this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);\n                Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);\n\n                this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;\n                this._angles.y = 0;\n                this._angles.z = this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;\n                this._dragging = true;\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n                this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\n                this.angle = 0;\n            }\n        });\n\n        this.dragBehavior.onDragEndObservable.add(() => {\n            this._dragging = false;\n            this._rotationDisplayPlane.setEnabled(false);\n        });\n\n        var tmpSnapEvent = { snapDistance: 0 };\n        var currentSnapDragDistance = 0;\n        var tmpMatrix = new Matrix();\n        var amountToRotate = new Quaternion();\n        this.dragBehavior.onDragObservable.add((event) => {\n            if (this.attachedNode) {\n                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n                var nodeScale = new Vector3(1, 1, 1);\n                var nodeQuaternion = new Quaternion(0, 0, 0, 1);\n                var nodeTranslation = new Vector3(0, 0, 0);\n                this._handlePivot();\n                this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);\n\n                var newVector = event.dragPlanePoint.subtract(nodeTranslation).normalize();\n                var originalVector = lastDragPosition.subtract(nodeTranslation).normalize();\n                var cross = Vector3.Cross(newVector, originalVector);\n                var dot = Vector3.Dot(newVector, originalVector);\n                var angle = Math.atan2(cross.length(), dot);\n                planeNormalTowardsCamera.copyFrom(planeNormal);\n                localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    nodeQuaternion.toRotationMatrix(rotationMatrix);\n                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n                }\n                // Flip up vector depending on which side the camera is on\n                let cameraFlipped = false;\n                if (gizmoLayer.utilityLayerScene.activeCamera) {\n                    var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslation).normalize();\n                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n                        planeNormalTowardsCamera.scaleInPlace(-1);\n                        localPlaneNormalTowardsCamera.scaleInPlace(-1);\n                        cameraFlipped = true;\n                    }\n                }\n                var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n                if (halfCircleSide) { angle = -angle; }\n\n                // Snapping logic\n                var snapped = false;\n                if (this.snapDistance != 0) {\n                    currentSnapDragDistance += angle;\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n                        var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n                        if (currentSnapDragDistance < 0) {\n                            dragSteps *= -1;\n                        }\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n                        angle = this.snapDistance * dragSteps;\n                        snapped = true;\n                    } else {\n                        angle = 0;\n                    }\n                }\n\n                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n                var quaternionCoefficient = Math.sin(angle / 2);\n                amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));\n\n                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n                if (tmpMatrix.determinant() > 0) {\n                    var tmpVector = new Vector3();\n                    amountToRotate.toEulerAnglesToRef(tmpVector);\n                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n                }\n\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    // Rotate selected mesh quaternion over fixed axis\n                    nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);\n                } else {\n                    // Rotate selected mesh quaternion over rotated axis\n                    amountToRotate.multiplyToRef(nodeQuaternion, nodeQuaternion);\n                }\n\n                // recompose matrix\n                this.attachedNode.getWorldMatrix().copyFrom(Matrix.Compose(nodeScale, nodeQuaternion, nodeTranslation));\n\n                lastDragPosition.copyFrom(event.dragPlanePoint);\n                if (snapped) {\n                    tmpSnapEvent.snapDistance = angle;\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\n                }\n                this._angles.y += angle;\n                this.angle += cameraFlipped ? -angle : angle;\n                this._rotationShaderMaterial.setVector3(\"angles\", this._angles);\n                this._matrixChanged();\n            }\n        });\n\n        var light = gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n\n        const cache: GizmoAxisCache = {\n            colliderMeshes: [collider],\n            gizmoMeshes: [rotationMesh],\n            material: this._coloredMaterial,\n            hoverMaterial: this._hoverMaterial,\n            disableMaterial: this._disableMaterial,\n            active: false,\n            dragBehavior: this.dragBehavior\n        };\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\n\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\n            if (this._customMeshSet) {\n                return;\n            }\n            // updating here the maxangle because ondragstart is too late (value already used) and the updated value is not taken into account\n            this.dragBehavior.maxDragAngle = PlaneRotationGizmo.MaxDragAngle;\n            this._isHovered = !!(cache.colliderMeshes.indexOf(<Mesh>pointerInfo?.pickInfo?.pickedMesh) != -1);\n            if (!this._parent) {\n                const material = cache.dragBehavior.enabled ? (this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial) : this._disableMaterial;\n                this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n            }\n        });\n\n        this.dragBehavior.onEnabledObservable.add((newState) => {\n            this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\n        });\n    }\n\n    /** Create Geometry for Gizmo */\n    private _createGizmoMesh(parentMesh: AbstractMesh, thickness: number, tessellation: number) {\n        let collider = CreateTorus(\"ignore\", {\n            diameter: 0.6,\n            thickness: 0.03 * thickness,\n            tessellation,\n        }, this.gizmoLayer.utilityLayerScene);\n        collider.visibility = 0;\n        let rotationMesh = CreateTorus(\"\", {\n            diameter: 0.6,\n            thickness: 0.005 * thickness,\n            tessellation,\n        }, this.gizmoLayer.utilityLayerScene);\n        rotationMesh.material = this._coloredMaterial;\n\n        // Position arrow pointing in its drag axis\n        rotationMesh.rotation.x = Math.PI / 2;\n        collider.rotation.x = Math.PI / 2;\n\n        parentMesh.addChild(rotationMesh);\n        parentMesh.addChild(collider);\n        return { rotationMesh, collider };\n    }\n\n    protected _attachedNodeChanged(value: Nullable<Node>) {\n        if (this.dragBehavior) {\n            this.dragBehavior.enabled = value ? true : false;\n        }\n    }\n\n    /**\n         * If the gizmo is enabled\n         */\n    public set isEnabled(value: boolean) {\n        this._isEnabled = value;\n        if (!value) {\n            this.attachedMesh = null;\n        }\n        else {\n            if (this._parent) {\n                this.attachedMesh = this._parent.attachedMesh;\n            }\n        }\n    }\n    public get isEnabled(): boolean {\n        return this._isEnabled;\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    public dispose() {\n        this.onSnapObservable.clear();\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n        this.dragBehavior.detach();\n        if (this._gizmoMesh) {\n            this._gizmoMesh.dispose();\n        }\n        if (this._rotationDisplayPlane) {\n            this._rotationDisplayPlane.dispose();\n        }\n        if (this._rotationShaderMaterial) {\n            this._rotationShaderMaterial.dispose();\n        }\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\n            if (matl) {\n                matl.dispose();\n            }\n        });\n        super.dispose();\n    }\n}\n"]}