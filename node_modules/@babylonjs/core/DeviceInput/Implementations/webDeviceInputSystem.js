import { Observable } from "../../Misc/observable.js";
import { Tools } from "../../Misc/tools.js";
import { DeviceEventFactory } from "../Helpers/eventFactory.js";
import { DeviceType, PointerInput } from "../InputDevices/deviceEnums.js";
/** @hidden */
var WebDeviceInputSystem = /** @class */ (function () {
    function WebDeviceInputSystem(engine) {
        var _this = this;
        // Private Members
        this._inputs = [];
        this._keyboardActive = false;
        this._pointerActive = false;
        this._usingSafari = Tools.IsSafari();
        this._keyboardDownEvent = function (evt) { };
        this._keyboardUpEvent = function (evt) { };
        this._keyboardBlurEvent = function (evt) { };
        this._pointerMoveEvent = function (evt) { };
        this._pointerDownEvent = function (evt) { };
        this._pointerUpEvent = function (evt) { };
        this._pointerWheelEvent = function (evt) { };
        this._pointerBlurEvent = function (evt) { };
        this._mouseId = -1;
        this._isUsingFirefox = navigator && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
        // Array to store active Pointer ID values; prevents issues with negative pointerIds
        this._activeTouchIds = [];
        this._rollingTouchId = 0; // Rolling ID number to assign; emulates Chrome assignment
        this._pointerInputClearObserver = null;
        this._gamepadConnectedEvent = function (evt) { };
        this._gamepadDisconnectedEvent = function (evt) { };
        this._eventPrefix = Tools.GetPointerPrefix(engine);
        this._engine = engine;
        this.onDeviceConnectedObservable = new Observable(function (observer) {
            // Iterate through each active device and rerun new callback
            for (var deviceType = 0; deviceType < _this._inputs.length; deviceType++) {
                var inputs = _this._inputs[deviceType];
                if (inputs) {
                    for (var deviceSlotKey in inputs) {
                        var deviceSlot = +deviceSlotKey;
                        if (_this._inputs[deviceType][deviceSlot]) {
                            _this.onDeviceConnectedObservable.notifyObserver(observer, { deviceType: deviceType, deviceSlot: deviceSlot });
                        }
                    }
                }
            }
        });
        this.onDeviceDisconnectedObservable = new Observable();
        this.onInputChangedObservable = new Observable();
        this.configureEvents();
    }
    /**
     * Configures events to work with an engine's active element
     */
    WebDeviceInputSystem.prototype.configureEvents = function () {
        var inputElement = this._engine.getInputElement();
        if (inputElement && this._elementToAttachTo !== inputElement) {
            // If the engine's input element has changed, unregister events from previous element
            if (this._elementToAttachTo) {
                this._removeEvents();
            }
            this._elementToAttachTo = inputElement;
            // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1
            this._elementToAttachTo.tabIndex = (this._elementToAttachTo.tabIndex !== -1) ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
            this._handleKeyActions();
            this._handlePointerActions();
            this._handleGamepadActions();
            // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse
            this._checkForConnectedDevices();
        }
    };
    // Public functions
    /**
     * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
     * @param deviceType Enum specifiying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     * @param inputIndex Id of input to be checked
     * @returns Current value of input
     */
    WebDeviceInputSystem.prototype.pollInput = function (deviceType, deviceSlot, inputIndex) {
        var device = this._inputs[deviceType][deviceSlot];
        if (!device) {
            throw "Unable to find device " + DeviceType[deviceType];
        }
        if (deviceType >= DeviceType.Xbox && deviceType <= DeviceType.Switch && navigator.getGamepads) {
            this._updateDevice(deviceType, deviceSlot, inputIndex);
        }
        var currentValue = device[inputIndex];
        if (currentValue === undefined) {
            throw "Unable to find input " + inputIndex + " for device " + DeviceType[deviceType] + " in slot " + deviceSlot;
        }
        return currentValue;
    };
    /**
     * Check for a specific device in the DeviceInputSystem
     * @param deviceType Type of device to check for
     * @returns bool with status of device's existence
     */
    WebDeviceInputSystem.prototype.isDeviceAvailable = function (deviceType) {
        return (this._inputs[deviceType] !== undefined);
    };
    /**
     * Dispose of all the eventlisteners
     */
    WebDeviceInputSystem.prototype.dispose = function () {
        // Observables
        this.onDeviceConnectedObservable.clear();
        this.onDeviceDisconnectedObservable.clear();
        this.onInputChangedObservable.clear();
        if (this._elementToAttachTo) {
            this._removeEvents();
            // Gamepad Events
            window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
            window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
        }
    };
    /**
     * Checks for existing connections to devices and register them, if necessary
     * Currently handles gamepads and mouse
     */
    WebDeviceInputSystem.prototype._checkForConnectedDevices = function () {
        if (navigator.getGamepads) {
            var gamepads = navigator.getGamepads();
            for (var _i = 0, gamepads_1 = gamepads; _i < gamepads_1.length; _i++) {
                var gamepad = gamepads_1[_i];
                if (gamepad) {
                    this._addGamePad(gamepad);
                }
            }
        }
        // If the device in use has mouse capabilities, pre-register mouse
        if (matchMedia('(pointer:fine)').matches) {
            // This will provide a dummy value for the cursor position and is expected to be overriden when the first mouse event happens.
            // There isn't any good way to get the current position outside of a pointer event so that's why this was done.
            this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
        }
    };
    // Private functions
    /**
     * Add a gamepad to the DeviceInputSystem
     * @param gamepad A single DOM Gamepad object
     */
    WebDeviceInputSystem.prototype._addGamePad = function (gamepad) {
        var deviceType = this._getGamepadDeviceType(gamepad.id);
        var deviceSlot = gamepad.index;
        this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
        this._gamepads = this._gamepads || new Array(gamepad.index + 1);
        this._gamepads[deviceSlot] = deviceType;
    };
    /**
     * Add pointer device to DeviceInputSystem
     * @param deviceType Type of Pointer to add
     * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)
     * @param currentX Current X at point of adding
     * @param currentY Current Y at point of adding
     */
    WebDeviceInputSystem.prototype._addPointerDevice = function (deviceType, deviceSlot, currentX, currentY) {
        this._pointerActive = true;
        this._registerDevice(deviceType, deviceSlot, WebDeviceInputSystem.MAX_POINTER_INPUTS);
        var pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */
        pointer[0] = currentX;
        pointer[1] = currentY;
    };
    /**
     * Add device and inputs to device array
     * @param deviceType Enum specifiying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     * @param numberOfInputs Number of input entries to create for given device
     */
    WebDeviceInputSystem.prototype._registerDevice = function (deviceType, deviceSlot, numberOfInputs) {
        if (deviceSlot === undefined) {
            throw "Unable to register device " + DeviceType[deviceType] + " to undefined slot.";
        }
        if (!this._inputs[deviceType]) {
            this._inputs[deviceType] = {};
        }
        if (!this._inputs[deviceType][deviceSlot]) {
            var device = new Array(numberOfInputs);
            for (var i = 0; i < numberOfInputs; i++) {
                device[i] = 0; /* set device input as unpressed */
            }
            this._inputs[deviceType][deviceSlot] = device;
            this.onDeviceConnectedObservable.notifyObservers({ deviceType: deviceType, deviceSlot: deviceSlot });
        }
    };
    /**
     * Given a specific device name, remove that device from the device map
     * @param deviceType Enum specifiying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     */
    WebDeviceInputSystem.prototype._unregisterDevice = function (deviceType, deviceSlot) {
        if (this._inputs[deviceType][deviceSlot]) {
            delete this._inputs[deviceType][deviceSlot];
            this.onDeviceDisconnectedObservable.notifyObservers({ deviceType: deviceType, deviceSlot: deviceSlot });
        }
    };
    /**
     * Handle all actions that come from keyboard interaction
     */
    WebDeviceInputSystem.prototype._handleKeyActions = function () {
        var _this = this;
        this._keyboardDownEvent = (function (evt) {
            if (!_this._keyboardActive) {
                _this._keyboardActive = true;
                _this._registerDevice(DeviceType.Keyboard, 0, WebDeviceInputSystem.MAX_KEYCODES);
            }
            var kbKey = _this._inputs[DeviceType.Keyboard][0];
            if (kbKey) {
                kbKey[evt.keyCode] = 1;
                var deviceEvent = evt;
                deviceEvent.deviceType = DeviceType.Keyboard;
                deviceEvent.deviceSlot = 0;
                deviceEvent.inputIndex = evt.keyCode;
                deviceEvent.previousState = 0;
                deviceEvent.currentState = kbKey[evt.keyCode];
                _this.onInputChangedObservable.notifyObservers(deviceEvent);
            }
        });
        this._keyboardUpEvent = (function (evt) {
            if (!_this._keyboardActive) {
                _this._keyboardActive = true;
                _this._registerDevice(DeviceType.Keyboard, 0, WebDeviceInputSystem.MAX_KEYCODES);
            }
            var kbKey = _this._inputs[DeviceType.Keyboard][0];
            if (kbKey) {
                kbKey[evt.keyCode] = 0;
                var deviceEvent = evt;
                deviceEvent.deviceType = DeviceType.Keyboard;
                deviceEvent.deviceSlot = 0;
                deviceEvent.inputIndex = evt.keyCode;
                deviceEvent.previousState = 1;
                deviceEvent.currentState = kbKey[evt.keyCode];
                _this.onInputChangedObservable.notifyObservers(deviceEvent);
            }
        });
        this._keyboardBlurEvent = (function (evt) {
            if (_this._keyboardActive) {
                var kbKey = _this._inputs[DeviceType.Keyboard][0];
                for (var i = 0; i < kbKey.length; i++) {
                    if (kbKey[i] !== 0) {
                        kbKey[i] = 0;
                        var evt_1 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 1, _this, _this._elementToAttachTo);
                        var deviceEvent = evt_1;
                        deviceEvent.deviceType = DeviceType.Keyboard;
                        deviceEvent.deviceSlot = 0;
                        deviceEvent.inputIndex = i;
                        deviceEvent.currentState = 0;
                        deviceEvent.previousState = 1;
                        _this.onInputChangedObservable.notifyObservers(deviceEvent);
                    }
                }
            }
        });
        this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
        this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
        this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
    };
    /**
     * Handle all actions that come from pointer interaction
     */
    WebDeviceInputSystem.prototype._handlePointerActions = function () {
        var _this = this;
        this._pointerMoveEvent = (function (evt) {
            var deviceType = _this._getPointerType(evt);
            var deviceSlot = (deviceType === DeviceType.Mouse) ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
            if (!_this._inputs[deviceType]) {
                _this._inputs[deviceType] = {};
            }
            if (!_this._inputs[deviceType][deviceSlot]) {
                _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
            }
            var pointer = _this._inputs[deviceType][deviceSlot];
            if (pointer) {
                // Store previous values for event
                var previousHorizontal = pointer[PointerInput.Horizontal];
                var previousVertical = pointer[PointerInput.Vertical];
                var previousDeltaHorizontal = pointer[PointerInput.DeltaHorizontal];
                var previousDeltaVertical = pointer[PointerInput.DeltaVertical];
                pointer[PointerInput.Horizontal] = evt.clientX;
                pointer[PointerInput.Vertical] = evt.clientY;
                pointer[PointerInput.DeltaHorizontal] = evt.movementX;
                pointer[PointerInput.DeltaVertical] = evt.movementY;
                var deviceEvent = evt;
                deviceEvent.deviceType = deviceType;
                deviceEvent.deviceSlot = deviceSlot;
                // The browser might use a move event in case
                // of simultaneous mouse buttons click for instance. So
                // in this case we stil need to propagate it.
                if (previousHorizontal !== evt.clientX) {
                    deviceEvent.inputIndex = PointerInput.Horizontal;
                    deviceEvent.previousState = previousHorizontal;
                    deviceEvent.currentState = pointer[PointerInput.Horizontal];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (previousVertical !== evt.clientY) {
                    deviceEvent.inputIndex = PointerInput.Vertical;
                    deviceEvent.previousState = previousVertical;
                    deviceEvent.currentState = pointer[PointerInput.Vertical];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (pointer[PointerInput.DeltaHorizontal] !== 0) {
                    deviceEvent.inputIndex = PointerInput.DeltaHorizontal;
                    deviceEvent.previousState = previousDeltaHorizontal;
                    deviceEvent.currentState = pointer[PointerInput.DeltaHorizontal];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (pointer[PointerInput.DeltaVertical] !== 0) {
                    deviceEvent.inputIndex = PointerInput.DeltaVertical;
                    deviceEvent.previousState = previousDeltaVertical;
                    deviceEvent.currentState = pointer[PointerInput.DeltaVertical];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                // Lets Propagate the event for move with same position.
                if (!_this._usingSafari && evt.button !== -1) {
                    deviceEvent.inputIndex = evt.button + 2;
                    deviceEvent.previousState = pointer[evt.button + 2];
                    pointer[evt.button + 2] = (pointer[evt.button + 2] ? 0 : 1); // Reverse state of button if evt.button has value
                    deviceEvent.currentState = pointer[evt.button + 2];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
            }
        });
        this._pointerDownEvent = (function (evt) {
            var deviceType = _this._getPointerType(evt);
            var deviceSlot = (deviceType === DeviceType.Mouse) ? 0 : evt.pointerId;
            if (deviceType === DeviceType.Touch) {
                deviceSlot = _this._rollingTouchId++;
                _this._activeTouchIds[deviceSlot] = evt.pointerId;
            }
            if (!_this._inputs[deviceType]) {
                _this._inputs[deviceType] = {};
            }
            if (!_this._inputs[deviceType][deviceSlot]) {
                _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
            }
            var pointer = _this._inputs[deviceType][deviceSlot];
            if (pointer) {
                var previousHorizontal = pointer[PointerInput.Horizontal];
                var previousVertical = pointer[PointerInput.Vertical];
                var previousButton = pointer[evt.button + 2];
                if (deviceType === DeviceType.Mouse) { // Mouse; Among supported browsers, value is either 1 or 0 for mouse
                    if (_this._mouseId === -1) {
                        if (evt.pointerId === undefined) { // If there is no pointerId (eg. manually dispatched MouseEvent)
                            _this._mouseId = _this._isUsingFirefox ? 0 : 1;
                        }
                        else {
                            _this._mouseId = evt.pointerId;
                        }
                    }
                    if (!document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
                        try {
                            _this._elementToAttachTo.setPointerCapture(_this._mouseId);
                        }
                        catch (e) {
                            // DO NOTHING
                        }
                    }
                }
                else { // Touch; Since touches are dynamically assigned, only set capture if we have an id
                    if (evt.pointerId && !document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
                        try {
                            _this._elementToAttachTo.setPointerCapture(evt.pointerId);
                        }
                        catch (e) {
                            // DO NOTHING
                        }
                    }
                }
                pointer[PointerInput.Horizontal] = evt.clientX;
                pointer[PointerInput.Vertical] = evt.clientY;
                pointer[evt.button + 2] = 1;
                var deviceEvent = evt;
                deviceEvent.deviceType = deviceType;
                deviceEvent.deviceSlot = deviceSlot;
                if (previousHorizontal !== evt.clientX) {
                    deviceEvent.inputIndex = PointerInput.Horizontal;
                    deviceEvent.previousState = previousHorizontal;
                    deviceEvent.currentState = pointer[PointerInput.Horizontal];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (previousVertical !== evt.clientY) {
                    deviceEvent.inputIndex = PointerInput.Vertical;
                    deviceEvent.previousState = previousVertical;
                    deviceEvent.currentState = pointer[PointerInput.Vertical];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                deviceEvent.inputIndex = evt.button + 2;
                deviceEvent.previousState = previousButton;
                deviceEvent.currentState = pointer[evt.button + 2];
                _this.onInputChangedObservable.notifyObservers(deviceEvent);
            }
        });
        this._pointerUpEvent = (function (evt) {
            var _a, _b, _c, _d, _e;
            var deviceType = _this._getPointerType(evt);
            var deviceSlot = (deviceType === DeviceType.Mouse) ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
            var pointer = (_a = _this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
            if (pointer && pointer[evt.button + 2] !== 0) {
                var previousHorizontal = pointer[PointerInput.Horizontal];
                var previousVertical = pointer[PointerInput.Vertical];
                var previousButton = pointer[evt.button + 2];
                pointer[PointerInput.Horizontal] = evt.clientX;
                pointer[PointerInput.Vertical] = evt.clientY;
                pointer[evt.button + 2] = 0;
                var deviceEvent = evt;
                deviceEvent.deviceType = deviceType;
                deviceEvent.deviceSlot = deviceSlot;
                if (previousHorizontal !== evt.clientX) {
                    deviceEvent.inputIndex = PointerInput.Horizontal;
                    deviceEvent.previousState = previousHorizontal;
                    deviceEvent.currentState = pointer[PointerInput.Horizontal];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (previousVertical !== evt.clientY) {
                    deviceEvent.inputIndex = PointerInput.Vertical;
                    deviceEvent.previousState = previousVertical;
                    deviceEvent.currentState = pointer[PointerInput.Vertical];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                deviceEvent.inputIndex = evt.button + 2;
                deviceEvent.previousState = previousButton;
                deviceEvent.currentState = pointer[evt.button + 2];
                if (deviceType === DeviceType.Mouse && _this._mouseId >= 0 && ((_c = (_b = _this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, _this._mouseId))) {
                    _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
                }
                else if (evt.pointerId && ((_e = (_d = _this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {
                    _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
                }
                _this.onInputChangedObservable.notifyObservers(deviceEvent);
                // We don't want to unregister the mouse because we may miss input data when a mouse is moving after a click
                if (deviceType !== DeviceType.Mouse) {
                    var idToRemove = _this._activeTouchIds.indexOf(evt.pointerId);
                    delete _this._activeTouchIds[idToRemove];
                    _this._unregisterDevice(deviceType, deviceSlot);
                }
            }
        });
        // Set Wheel Event Name, code originally from scene.inputManager
        this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
            document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
                "DOMMouseScroll"; // let's assume that remaining browsers are older Firefox
        // Code originally in scene.inputManager.ts
        // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.
        // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.
        // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)
        var passiveSupported = false;
        var noop = function () { };
        try {
            var options = {
                passive: {
                    get: function () {
                        passiveSupported = true;
                    }
                }
            };
            this._elementToAttachTo.addEventListener("test", noop, options);
            this._elementToAttachTo.removeEventListener("test", noop, options);
        }
        catch (e) {
            /* */
        }
        this._pointerBlurEvent = (function (evt) {
            var _a, _b, _c, _d, _e;
            // Handle mouse buttons
            if (_this.isDeviceAvailable(DeviceType.Mouse)) {
                var pointer = _this._inputs[DeviceType.Mouse][0];
                if (_this._mouseId >= 0 && ((_b = (_a = _this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, _this._mouseId))) {
                    _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
                }
                for (var i = 0; i <= PointerInput.BrowserForward; i++) {
                    if (pointer[i + 2] === 1) {
                        pointer[i + 2] = 0;
                        var evt_2 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, i + 2, 1, _this, _this._elementToAttachTo);
                        var deviceEvent = evt_2;
                        deviceEvent.deviceType = DeviceType.Mouse;
                        deviceEvent.deviceSlot = 0;
                        deviceEvent.inputIndex = i + 2;
                        deviceEvent.currentState = pointer[i + 2];
                        deviceEvent.previousState = 1;
                        _this.onInputChangedObservable.notifyObservers(deviceEvent);
                    }
                }
            }
            // Handle Active Touches
            if (_this.isDeviceAvailable(DeviceType.Touch)) {
                var pointer = _this._inputs[DeviceType.Touch];
                // Get list of active touch ids and clear each one in the inputs array
                for (var deviceSlotKey in Object.keys(_this._activeTouchIds)) {
                    var deviceSlot = +deviceSlotKey;
                    var pointerId = _this._activeTouchIds[deviceSlot];
                    if ((_d = (_c = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {
                        _this._elementToAttachTo.releasePointerCapture(pointerId);
                    }
                    if (((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {
                        pointer[deviceSlot][PointerInput.LeftClick] = 0;
                        var evt_3 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, pointerId, PointerInput.LeftClick, 1, _this, _this._elementToAttachTo);
                        var deviceEvent = evt_3;
                        deviceEvent.deviceType = DeviceType.Mouse;
                        deviceEvent.deviceSlot = deviceSlot;
                        deviceEvent.inputIndex = PointerInput.LeftClick;
                        deviceEvent.currentState = pointer[deviceSlot][PointerInput.LeftClick];
                        deviceEvent.previousState = 1;
                        _this.onInputChangedObservable.notifyObservers(deviceEvent);
                        _this._unregisterDevice(DeviceType.Touch, deviceSlot);
                    }
                }
                // Clear all active touches
                while (_this._activeTouchIds.pop() !== undefined) { }
            }
        });
        this._pointerWheelEvent = (function (evt) {
            var deviceType = DeviceType.Mouse;
            var deviceSlot = 0;
            if (!_this._inputs[deviceType]) {
                _this._inputs[deviceType] = [];
            }
            if (!_this._inputs[deviceType][deviceSlot]) {
                _this._pointerActive = true;
                _this._registerDevice(deviceType, deviceSlot, WebDeviceInputSystem.MAX_POINTER_INPUTS);
            }
            var pointer = _this._inputs[deviceType][deviceSlot];
            if (pointer) {
                // Store previous values for event
                var previousWheelScrollX = pointer[PointerInput.MouseWheelX];
                var previousWheelScrollY = pointer[PointerInput.MouseWheelY];
                var previousWheelScrollZ = pointer[PointerInput.MouseWheelZ];
                pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
                pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
                pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
                var deviceEvent = evt;
                deviceEvent.deviceType = deviceType;
                deviceEvent.deviceSlot = deviceSlot;
                if (pointer[PointerInput.MouseWheelX] !== 0) {
                    deviceEvent.inputIndex = PointerInput.MouseWheelX;
                    deviceEvent.previousState = previousWheelScrollX;
                    deviceEvent.currentState = pointer[PointerInput.MouseWheelX];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (pointer[PointerInput.MouseWheelY] !== 0) {
                    deviceEvent.inputIndex = PointerInput.MouseWheelY;
                    deviceEvent.previousState = previousWheelScrollY;
                    deviceEvent.currentState = pointer[PointerInput.MouseWheelY];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
                if (pointer[PointerInput.MouseWheelZ] !== 0) {
                    deviceEvent.inputIndex = PointerInput.MouseWheelZ;
                    deviceEvent.previousState = previousWheelScrollZ;
                    deviceEvent.currentState = pointer[PointerInput.MouseWheelZ];
                    _this.onInputChangedObservable.notifyObservers(deviceEvent);
                }
            }
        });
        this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
        this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
        this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
        // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame
        this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(function () {
            if (_this.isDeviceAvailable(DeviceType.Mouse)) {
                var pointer = _this._inputs[DeviceType.Mouse][0];
                pointer[PointerInput.MouseWheelX] = 0;
                pointer[PointerInput.MouseWheelY] = 0;
                pointer[PointerInput.MouseWheelZ] = 0;
                pointer[PointerInput.DeltaHorizontal] = 0;
                pointer[PointerInput.DeltaVertical] = 0;
            }
        });
    };
    /**
     * Handle all actions that come from gamepad interaction
     */
    WebDeviceInputSystem.prototype._handleGamepadActions = function () {
        var _this = this;
        this._gamepadConnectedEvent = (function (evt) {
            _this._addGamePad(evt.gamepad);
        });
        this._gamepadDisconnectedEvent = (function (evt) {
            if (_this._gamepads) {
                var deviceType = _this._getGamepadDeviceType(evt.gamepad.id);
                var deviceSlot = evt.gamepad.index;
                _this._unregisterDevice(deviceType, deviceSlot);
                delete _this._gamepads[deviceSlot];
            }
        });
        window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
        window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
    };
    /**
     * Update all non-event based devices with each frame
     * @param deviceType Enum specifiying device type
     * @param deviceSlot "Slot" or index that device is referenced in
     * @param inputIndex Id of input to be checked
     */
    WebDeviceInputSystem.prototype._updateDevice = function (deviceType, deviceSlot, inputIndex) {
        // Gamepads
        var gp = navigator.getGamepads()[deviceSlot];
        if (gp && deviceType === this._gamepads[deviceSlot]) {
            var device = this._inputs[deviceType][deviceSlot];
            if (inputIndex >= gp.buttons.length) {
                device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
            }
            else {
                device[inputIndex] = gp.buttons[inputIndex].value;
            }
        }
    };
    /**
     * Gets DeviceType from the device name
     * @param deviceName Name of Device from DeviceInputSystem
     * @returns DeviceType enum value
     */
    WebDeviceInputSystem.prototype._getGamepadDeviceType = function (deviceName) {
        if (deviceName.indexOf("054c") !== -1 && deviceName.indexOf("0ce6") === -1) { // DualShock 4 Gamepad
            return DeviceType.DualShock;
        }
        else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) { // Xbox Gamepad
            return DeviceType.Xbox;
        }
        else if (deviceName.indexOf("057e") !== -1) { // Switch Gamepad
            return DeviceType.Switch;
        }
        return DeviceType.Generic;
    };
    /**
     * Get DeviceType from a given pointer/mouse/touch event.
     * @param evt PointerEvent to evaluate
     * @returns DeviceType interpreted from event
     */
    WebDeviceInputSystem.prototype._getPointerType = function (evt) {
        var deviceType = DeviceType.Mouse;
        if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
            deviceType = DeviceType.Touch;
        }
        return deviceType;
    };
    /**
     * Remove events from active input element
     */
    WebDeviceInputSystem.prototype._removeEvents = function () {
        // Blur Events
        this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
        this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
        // Keyboard Events
        if (this._keyboardActive) {
            this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
            this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
        }
        // Pointer Events
        if (this._pointerActive) {
            this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
            this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
            this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
            this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
            if (this._pointerInputClearObserver) {
                this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
            }
        }
    };
    /** Max number of keycodes */
    WebDeviceInputSystem.MAX_KEYCODES = 255;
    /** Max number of pointer inputs */
    WebDeviceInputSystem.MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
    return WebDeviceInputSystem;
}());
export { WebDeviceInputSystem };
//# sourceMappingURL=webDeviceInputSystem.js.map