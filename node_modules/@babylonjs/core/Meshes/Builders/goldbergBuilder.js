import { __extends } from "tslib";
import { Vector3 } from "../../Maths/math.vector.js";
import { Color4 } from '../../Maths/math.color.js';
import { Mesh } from "../../Meshes/mesh.js";
import { VertexData } from "../mesh.vertexData.js";
import { Logger } from "../../Misc/logger.js";
import { _PrimaryIsoTriangle, GeodesicData } from "../geodesicMesh.js";
import { VertexBuffer } from "../../Buffers/buffer.js";
/**
 * Creates the Mesh for a Goldberg Polyhedron
 * @param name defines the name of the mesh
 * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
 * * m number of horizontal steps along an isogrid
 * * n number of angled steps along an isogrid
 * * size the size of the Goldberg, optional default 1
 * * sizeX allows stretching in the x direction, optional, default size
 * * sizeY allows stretching in the y direction, optional, default size
 * * sizeZ allows stretching in the z direction, optional, default size
 * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
 * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
 * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
 * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
 * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 * @param goldBergData polyhedronData defining the Goldberg polyhedron
 * @returns GoldbergSphere mesh
 */
export function CreateGoldbergVertexData(options, goldbergData) {
    var size = options.size;
    var sizeX = options.sizeX || size || 1;
    var sizeY = options.sizeY || size || 1;
    var sizeZ = options.sizeZ || size || 1;
    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
    var positions = new Array();
    var indices = new Array();
    var normals = new Array();
    var uvs = new Array();
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    for (var v = 0; v < goldbergData.vertex.length; v++) {
        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);
        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);
        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);
        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);
    }
    var index = 0;
    for (var f = 0; f < goldbergData.face.length; f++) {
        var verts = goldbergData.face[f];
        var a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
        var b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
        var c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
        var ba = b.subtract(a);
        var ca = c.subtract(a);
        var norm = Vector3.Cross(ca, ba).normalize();
        for (var v = 0; v < verts.length; v++) {
            normals.push(norm.x, norm.y, norm.z);
            var pdata = goldbergData.vertex[verts[v]];
            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);
            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), (pdata[1] * sizeY - minY) / (maxY - minY));
        }
        for (var v = 0; v < verts.length - 2; v++) {
            indices.push(index, index + v + 2, index + v + 1);
        }
        index += verts.length;
    }
    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
    var vertexData = new VertexData();
    vertexData.positions = positions;
    vertexData.indices = indices;
    vertexData.normals = normals;
    vertexData.uvs = uvs;
    return vertexData;
}
/**
 * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces
 * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron
 * @param name defines the name of the mesh
 * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty
 * * m number of horizontal steps along an isogrid
 * * n number of angled steps along an isogrid
 * * size the size of the Goldberg, optional default 1
 * * sizeX allows stretching in the x direction, optional, default size
 * * sizeY allows stretching in the y direction, optional, default size
 * * sizeZ allows stretching in the z direction, optional, default size
 * * updatable defines if the mesh must be flagged as updatable
 * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
 * @param scene defines the hosting scene
 * @returns Goldberg mesh
 */
export function CreateGoldberg(name, options, scene) {
    if (scene === void 0) { scene = null; }
    var m = options.m || 1;
    if (m !== Math.floor(m)) {
        m === Math.floor(m);
        Logger.Warn("m not an integer only floor(m) used");
    }
    var n = options.n || 0;
    if (n !== Math.floor(n)) {
        n === Math.floor(n);
        Logger.Warn("n not an integer only floor(n) used");
    }
    if (n > m) {
        var temp = n;
        n = m;
        m = temp;
        Logger.Warn("n > m therefore m and n swapped");
    }
    var primTri = new _PrimaryIsoTriangle();
    primTri.build(m, n);
    var geodesicData = GeodesicData.BuildGeodesicData(primTri);
    var goldbergData = geodesicData.toGoldbergData();
    var goldberg = new GoldbergMesh(name);
    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
    goldberg._originalBuilderSideOrientation = options.sideOrientation;
    var vertexData = CreateGoldbergVertexData(options, goldbergData);
    vertexData.applyToMesh(goldberg, options.updatable);
    goldberg.nbSharedFaces = geodesicData.sharedNodes;
    goldberg.nbUnsharedFaces = geodesicData.poleNodes;
    goldberg.adjacentFaces = geodesicData.adjacentFaces;
    goldberg.nbFaces = goldberg.nbSharedFaces + goldberg.nbUnsharedFaces;
    goldberg.nbFacesAtPole = (goldberg.nbUnsharedFaces - 12) / 12;
    for (var f = 0; f < geodesicData.vertex.length; f++) {
        goldberg.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));
        goldberg.faceColors.push(new Color4(1, 1, 1, 1));
    }
    for (var f = 0; f < goldbergData.face.length; f++) {
        var verts = goldbergData.face[f];
        var a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
        var b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
        var c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
        var ba = b.subtract(a);
        var ca = c.subtract(a);
        var norm = Vector3.Cross(ca, ba).normalize();
        var z = Vector3.Cross(ca, norm).normalize();
        goldberg.faceXaxis.push(ca.normalize());
        goldberg.faceYaxis.push(norm);
        goldberg.faceZaxis.push(z);
    }
    goldberg.setMetadata();
    return goldberg;
}
/**
 * Mixin to extend the Mesh class to a Goldberg class
 * When applied to extend a mesh tthe mesh must be an import of a previously exported Goldberg mesh
 */
function GoldbergCreate(Base) {
    return /** @class */ (function (_super) {
        __extends(Goldberg, _super);
        function Goldberg() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.faceColors = [];
            _this.faceCenters = [];
            _this.faceZaxis = [];
            _this.faceXaxis = [];
            _this.faceYaxis = [];
            return _this;
        }
        Goldberg.prototype.setMetadata = function () {
            this.metadata = {
                nbSharedFaces: this.nbSharedFaces,
                nbUnsharedFaces: this.nbUnsharedFaces,
                nbFacesAtPole: this.nbFacesAtPole,
                nbFaces: this.nbFaces,
                faceCenters: this.faceCenters,
                faceXaxis: this.faceXaxis,
                faceYaxis: this.faceYaxis,
                faceZaxis: this.faceZaxis,
                adjacentFaces: this.adjacentFaces
            };
        };
        Goldberg.prototype.relFace = function (poleOrShared, fromPole) {
            if (fromPole === void 0) {
                if (poleOrShared > this.nbUnsharedFaces - 1) {
                    Logger.Warn("Maximum number of unshared faces used");
                    poleOrShared = this.nbUnsharedFaces - 1;
                }
                return this.nbUnsharedFaces + poleOrShared;
            }
            if (poleOrShared > 11) {
                Logger.Warn("Last pole used");
                poleOrShared = 11;
            }
            if (fromPole > this.nbFacesAtPole - 1) {
                Logger.Warn("Maximum number of faces at a pole used");
                fromPole = this.nbFacesAtPole - 1;
            }
            return 12 + poleOrShared * this.nbFacesAtPole + fromPole;
        };
        Goldberg.prototype.refreshFaceData = function () {
            this.nbSharedFaces = this.metadata.nbSharedFaces;
            this.nbUnsharedFaces = this.metadata.nbUnsharedFaces;
            this.nbFacesAtPole = this.metadata.nbFacesAtPole;
            this.adjacentFaces = this.metadata.adjacentFaces;
            this.nbFaces = this.metadata.nbFaces;
            this.faceCenters = this.metadata.faceCenters,
                this.faceXaxis = this.metadata.faceXaxis,
                this.faceYaxis = this.metadata.faceYaxis,
                this.faceZaxis = this.metadata.faceZaxis;
        };
        Goldberg.prototype.changeFaceColors = function (colorRange) {
            for (var i = 0; i < colorRange.length; i++) {
                var min = colorRange[i][0];
                var max = colorRange[i][1];
                var col = colorRange[i][2];
                for (var f = min; f < max + 1; f++) {
                    this.faceColors[f] = col;
                }
            }
            var newCols = [];
            for (var f = 0; f < 12; f++) {
                for (var i = 0; i < 5; i++) {
                    newCols.push(this.faceColors[f].r, this.faceColors[f].g, this.faceColors[f].b, this.faceColors[f].a);
                }
            }
            for (var f = 12; f < this.faceColors.length; f++) {
                for (var i = 0; i < 6; i++) {
                    newCols.push(this.faceColors[f].r, this.faceColors[f].g, this.faceColors[f].b, this.faceColors[f].a);
                }
            }
            return newCols;
        };
        Goldberg.prototype.setFaceColors = function (colorRange) {
            var newCols = this.changeFaceColors(colorRange);
            this.setVerticesData(VertexBuffer.ColorKind, newCols);
        };
        Goldberg.prototype.updateFaceColors = function (colorRange) {
            var newCols = this.changeFaceColors(colorRange);
            this.updateVerticesData(VertexBuffer.ColorKind, newCols);
        };
        Goldberg.prototype.changeFaceUVs = function (uvRange) {
            var uvs = this.getVerticesData(VertexBuffer.UVKind);
            for (var i = 0; i < uvRange.length; i++) {
                var min = uvRange[i][0];
                var max = uvRange[i][1];
                var center = uvRange[i][2];
                var radius = uvRange[i][3];
                var angle = uvRange[i][4];
                var points5 = [];
                var points6 = [];
                var u = void 0;
                var v = void 0;
                for (var p = 0; p < 5; p++) {
                    u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);
                    v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);
                    if (u < 0) {
                        u = 0;
                    }
                    if (u > 1) {
                        u = 1;
                    }
                    points5.push(u, v);
                }
                for (var p = 0; p < 6; p++) {
                    u = center.x + radius * Math.cos(angle + p * Math.PI / 3);
                    v = center.y + radius * Math.sin(angle + p * Math.PI / 3);
                    if (u < 0) {
                        u = 0;
                    }
                    if (u > 1) {
                        u = 1;
                    }
                    points6.push(u, v);
                }
                for (var f = min; f < Math.min(12, max + 1); f++) {
                    for (var p = 0; p < 5; p++) {
                        uvs[10 * f + 2 * p] = points5[2 * p];
                        uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];
                    }
                }
                for (var f = Math.max(12, min); f < max + 1; f++) {
                    for (var p = 0; p < 6; p++) {
                        //120 + 12 * (f - 12) = 12 * f - 24
                        uvs[12 * f - 24 + 2 * p] = points6[2 * p];
                        uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];
                    }
                }
            }
            return uvs;
        };
        Goldberg.prototype.setFaceUVs = function (uvRange) {
            var newUVs = this.changeFaceUVs(uvRange);
            this.setVerticesData(VertexBuffer.UVKind, newUVs);
        };
        Goldberg.prototype.updateFaceUVs = function (uvRange) {
            var newUVs = this.changeFaceUVs(uvRange);
            this.updateVerticesData(VertexBuffer.UVKind, newUVs);
        };
        Goldberg.prototype.placeOnFaceAt = function (mesh, face, position) {
            var orientation = Vector3.RotationFromAxis(this.faceXaxis[face], this.faceYaxis[face], this.faceZaxis[face]);
            mesh.rotation = orientation;
            mesh.position = this.faceCenters[face].add(this.faceXaxis[face].scale(position.x)).add(this.faceYaxis[face].scale(position.y)).add(this.faceZaxis[face].scale(position.z));
        };
        return Goldberg;
    }(Base));
}
/**
 * Function to use when extending the mesh class to a Goldberg class
 */
var GoldbergMesh = GoldbergCreate(Mesh);
/**
 * Function to use when extending the mesh class to a Goldberg class
 */
export var ExtendMeshToGoldberg = function (mesh) {
    var metadata = mesh.metadata;
    metadata.faceCenters = metadata.faceCenters.map(function (el) { return new Vector3(el._x, el._y, el._z); });
    metadata.faceZaxis = metadata.faceZaxis.map(function (el) { return new Vector3(el._x, el._y, el._z); });
    metadata.faceXaxis = metadata.faceXaxis.map(function (el) { return new Vector3(el._x, el._y, el._z); });
    metadata.faceYaxis = metadata.faceYaxis.map(function (el) { return new Vector3(el._x, el._y, el._z); });
    var positions = mesh.getVerticesData(VertexBuffer.PositionKind);
    var normals = mesh.getVerticesData(VertexBuffer.NormalKind);
    var colors = mesh.getVerticesData(VertexBuffer.ColorKind);
    var uvs = mesh.getVerticesData(VertexBuffer.UVKind);
    var indices = mesh.getIndices();
    var vertexData = new VertexData();
    vertexData.positions = positions;
    vertexData.indices = indices;
    vertexData.normals = normals;
    vertexData.colors = colors;
    vertexData.uvs = uvs;
    var updatable = mesh.isVertexBufferUpdatable(VertexBuffer.PositionKind);
    updatable = updatable && mesh.isVertexBufferUpdatable(VertexBuffer.NormalKind);
    updatable = updatable && mesh.isVertexBufferUpdatable(VertexBuffer.ColorKind);
    updatable = updatable && mesh.isVertexBufferUpdatable(VertexBuffer.UVKind);
    var goldberg = new GoldbergMesh(mesh.name);
    vertexData.applyToMesh(goldberg, updatable);
    goldberg.metadata = metadata;
    goldberg.refreshFaceData();
    goldberg.material = mesh.material;
    mesh.dispose();
    return goldberg;
};
//# sourceMappingURL=goldbergBuilder.js.map