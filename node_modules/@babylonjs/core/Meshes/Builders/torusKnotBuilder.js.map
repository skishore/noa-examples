{"version":3,"file":"torusKnotBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/torusKnotBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Vector4, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\n\r\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n/**\r\n * Creates the VertexData for a TorusKnot\r\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n  * * radius the radius of the torus knot, optional, default 2\r\n  * * tube the thickness of the tube, optional, default 0.5\r\n  * * radialSegments the number of sides on each tube segments, optional, default 32\r\n  * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n  * * p the number of windings around the z axis, optional,  default 2\r\n  * * q the number of windings around the x axis, optional,  default 3\r\n  * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n  * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n  * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the Torus Knot\r\n */\r\nexport function CreateTorusKnotVertexData(options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }): VertexData {\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n\r\n    var radius = options.radius || 2;\r\n    var tube = options.tube || 0.5;\r\n    var radialSegments = options.radialSegments || 32;\r\n    var tubularSegments = options.tubularSegments || 32;\r\n    var p = options.p || 2;\r\n    var q = options.q || 3;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    var getPos = (angle: number) => {\r\n\r\n        var cu = Math.cos(angle);\r\n        var su = Math.sin(angle);\r\n        var quOverP = q / p * angle;\r\n        var cs = Math.cos(quOverP);\r\n\r\n        var tx = radius * (2 + cs) * 0.5 * cu;\r\n        var ty = radius * (2 + cs) * su * 0.5;\r\n        var tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    var i: number;\r\n    var j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        var modI = i % radialSegments;\r\n        var u = modI / radialSegments * 2 * p * Math.PI;\r\n        var p1 = getPos(u);\r\n        var p2 = getPos(u + 0.01);\r\n        var tang = p2.subtract(p1);\r\n        var n = p2.add(p1);\r\n\r\n        var bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var modJ = j % tubularSegments;\r\n            var v = modJ / tubularSegments * 2 * Math.PI;\r\n            var cx = -tube * Math.cos(v);\r\n            var cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var jNext = (j + 1) % tubularSegments;\r\n            var a = i * tubularSegments + j;\r\n            var b = (i + 1) * tubularSegments + j;\r\n            var c = (i + 1) * tubularSegments + jNext;\r\n            var d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d); indices.push(b); indices.push(a);\r\n            indices.push(d); indices.push(c); indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus knot mesh\r\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the torus knot mesh\r\n * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n */\r\nexport function CreateTorusKnot(name: string, options: { radius?: number, tube?: number, radialSegments?: number, tubularSegments?: number, p?: number, q?: number, updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 } = {}, scene: any): Mesh {\r\n    var torusKnot = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    var vertexData = CreateTorusKnotVertexData(options);\r\n\r\n    vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n    return torusKnot;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorusKnot instead\r\n */\r\nexport const TorusKnotBuilder = {\r\n    CreateTorusKnot\r\n};\r\n\r\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\r\n\r\nMesh.CreateTorusKnot = (name: string, radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tube,\r\n        radialSegments,\r\n        tubularSegments,\r\n        p,\r\n        q,\r\n        sideOrientation,\r\n        updatable\r\n    };\r\n\r\n    return CreateTorusKnot(name, options, scene);\r\n};"]}