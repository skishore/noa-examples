{"version":3,"file":"WebXRImageTracking.js","sourceRoot":"","sources":["../../../../sourceES6/core/XR/features/WebXRImageTracking.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Nullable } from \"../../types\";\r\n\r\ndeclare const XRImageTrackingResult: XRImageTrackingResult;\r\n\r\n/**\r\n * Options interface for the background remover plugin\r\n */\r\nexport interface IWebXRImageTrackingOptions {\r\n    /**\r\n     * A required array with images to track\r\n     */\r\n    images: {\r\n        /**\r\n         * The source of the image. can be a URL or an image bitmap\r\n         */\r\n        src: string | ImageBitmap;\r\n        /**\r\n         * The estimated width in the real world (in meters)\r\n         */\r\n        estimatedRealWorldWidth: number; // In meters!\r\n    }[];\r\n}\r\n\r\n/**\r\n * An object representing an image tracked by the system\r\n */\r\nexport interface IWebXRTrackedImage {\r\n    /**\r\n     * The ID of this image (which is the same as the position in the array that was used to initialize the feature)\r\n     */\r\n    id: number;\r\n    /**\r\n     * Is the transformation provided emulated. If it is, the system \"guesses\" its real position. Otherwise it can be considered as exact position.\r\n     */\r\n    emulated?: boolean;\r\n    /**\r\n     * Just in case it is needed - the image bitmap that is being tracked\r\n     */\r\n    originalBitmap: ImageBitmap;\r\n    /**\r\n     * The native XR result image tracking result, untouched\r\n     */\r\n    xrTrackingResult?: XRImageTrackingResult;\r\n    /**\r\n     * Width in real world (meters)\r\n     */\r\n    realWorldWidth?: number;\r\n    /**\r\n     * A transformation matrix of this current image in the current reference space.\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The width/height ratio of this image. can be used to calculate the size of the detected object/image\r\n     */\r\n    ratio?: number;\r\n}\r\n\r\n/**\r\n * Image tracking for immersive AR sessions.\r\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\r\n */\r\nexport class WebXRImageTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.IMAGE_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This will be triggered if the underlying system deems an image untrackable.\r\n     * The index is the index of the image from the array used to initialize the feature.\r\n     */\r\n    public onUntrackableImageFoundObservable: Observable<number> = new Observable();\r\n    /**\r\n     * An image was deemed trackable, and the system will start tracking it.\r\n     */\r\n    public onTrackableImageFoundObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n    /**\r\n     * The image was found and its state was updated.\r\n     */\r\n    public onTrackedImageUpdatedObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n\r\n    private _trackedImages: IWebXRTrackedImage[] = [];\r\n\r\n    private _originalTrackingRequest: XRTrackedImageInit[];\r\n\r\n    /**\r\n     * constructs the image tracking feature\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * read-only options to be used in this module\r\n         */\r\n        public readonly options: IWebXRImageTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"image-tracking\";\r\n        if (this.options.images.length === 0) {\r\n            // no images provided?... return.\r\n            return;\r\n        }\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        return super.attach();\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        return super.detach();\r\n    }\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRImageTrackingResult !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Get a tracked image by its ID.\r\n     *\r\n     * @param id the id of the image to load (position in the init array)\r\n     * @returns a trackable image, if exists in this location\r\n     */\r\n    public getTrackedImageById(id: number): Nullable<IWebXRTrackedImage> {\r\n        return this._trackedImages[id] || null;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._trackedImages.forEach((trackedImage) => {\r\n            trackedImage.originalBitmap.close();\r\n        });\r\n        this._trackedImages.length = 0;\r\n        this.onTrackableImageFoundObservable.clear();\r\n        this.onUntrackableImageFoundObservable.clear();\r\n        this.onTrackedImageUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object fo the xr session init object.\r\n     */\r\n    public async getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        if (!this.options.images || !this.options.images.length) {\r\n            return {};\r\n        }\r\n        const promises = this.options.images.map((image) => {\r\n            if (typeof image.src === \"string\") {\r\n                const p = new Promise<ImageBitmap>((resolve, reject) => {\r\n                    if (typeof image.src === \"string\") {\r\n                        const img = new Image();\r\n                        img.src = image.src;\r\n                        img.onload = () => {\r\n                            img.decode().then(() => {\r\n                                this._xrSessionManager.scene.getEngine().createImageBitmap(img).then((imageBitmap) => {\r\n                                    resolve(imageBitmap);\r\n                                });\r\n                            });\r\n                        };\r\n                        img.onerror = () => {\r\n                            Tools.Error(`Error loading image ${image.src}`);\r\n                            reject(`Error loading image ${image.src}`);\r\n                        };\r\n                    }\r\n                });\r\n                return p;\r\n            } else {\r\n                return Promise.resolve(image.src); // resolve is probably unneeded\r\n            }\r\n        });\r\n\r\n        const images = await Promise.all(promises);\r\n\r\n        this._originalTrackingRequest = images.map((image, idx) => {\r\n            return {\r\n                image,\r\n                widthInMeters: this.options.images[idx].estimatedRealWorldWidth,\r\n            };\r\n        });\r\n\r\n        return {\r\n            trackedImages: this._originalTrackingRequest,\r\n        };\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!_xrFrame.getImageTrackingResults) {\r\n            return;\r\n        }\r\n        const imageTrackedResults = _xrFrame.getImageTrackingResults();\r\n        for (const result of imageTrackedResults) {\r\n            let changed = false;\r\n            const imageIndex = result.index;\r\n\r\n            const imageObject = this._trackedImages[imageIndex];\r\n            if (!imageObject) {\r\n                // something went wrong!\r\n                continue;\r\n            }\r\n\r\n            imageObject.xrTrackingResult = result;\r\n            if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\r\n                imageObject.realWorldWidth = result.measuredWidthInMeters;\r\n                changed = true;\r\n            }\r\n\r\n            // Get the pose of the image relative to a reference space.\r\n            const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\r\n\r\n            if (pose) {\r\n                const mat = imageObject.transformationMatrix;\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                changed = true;\r\n            }\r\n\r\n            const state = result.trackingState;\r\n            const emulated = state === \"emulated\";\r\n\r\n            if (imageObject.emulated !== emulated) {\r\n                imageObject.emulated = emulated;\r\n                changed = true;\r\n            }\r\n            if (changed) {\r\n                this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _init() {\r\n        if (!this._xrSessionManager.session.getTrackedImageScores) {\r\n            return;\r\n        }\r\n        //\r\n        const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\r\n        // check the scores for all\r\n        for (let idx = 0; idx < imageScores.length; ++idx) {\r\n            if (imageScores[idx] == \"untrackable\") {\r\n                this.onUntrackableImageFoundObservable.notifyObservers(idx);\r\n            } else {\r\n                const originalBitmap = this._originalTrackingRequest[idx].image;\r\n                const imageObject: IWebXRTrackedImage = {\r\n                    id: idx,\r\n                    originalBitmap,\r\n                    transformationMatrix: new Matrix(),\r\n                    ratio: originalBitmap.width / originalBitmap.height,\r\n                };\r\n                this._trackedImages[idx] = imageObject;\r\n                this.onTrackableImageFoundObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRImageTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRImageTracking(xrSessionManager, options);\r\n    },\r\n    WebXRImageTracking.Version,\r\n    false\r\n);\r\n"]}